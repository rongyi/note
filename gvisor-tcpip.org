#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: gvisor-tcpip
#+DATE: <2021-07-30 五>
#+AUTHOR: ry
#+EMAIL: hiarongyi@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.3 (Org mode 9.1.9)
* 简介
  yes! gvisor里竟然包含了tcpip的golang实现。本文来撸一撸。

  本人读的版本commit： 28291a5a5d25633c8bdf45ed5affe90f779c74b4


* PacketBuffer
  PacketBuffer是一个报文的结构封装贯穿于整个流程中。所以先把 PacketBuffer 了解一下。
** gvisor/pkg/buffer
   这个package抽象了内存表示。其中buffer.View是离散的内存封装，内存最小的单位是buffer：
   #+BEGIN_SRC go
///home/coder/go/src/github.com/google/gvisor/pkg/buffer/buffer.go:24
type buffer struct {
  data  []byte
  read  int
  write int
  bufferEntry
}
   #+END_SRC
   两个指针read/write表示读取的长度和写的长度。函数 Full/ReadSize/WriteSize 可以看出来用意。 bufferEntry用于把buffer串起来。

   封装了个函数可以去抠掉一部分data的接口： Remove，其他的都很简洁，这个Remove说一下。

   为了表示区间增加了个Range的表示
   #+BEGIN_SRC go
// A Range specifies a range of buffer.
type Range struct {
  begin int
  end   int
}
//应该还是这种范围[begin, end)
   #+END_SRC
   Range的Intersect方法实在是骚。
   #+BEGIN_SRC go
///home/coder/go/src/github.com/google/gvisor/pkg/buffer/buffer.go:51
// Remove removes r from the unread portion. It returns false if r does not
// fully reside in b.
func (b *buffer) Remove(r Range) bool {
  sz := b.ReadSize()
  switch {
  case r.Len() != r.Intersect(Range{end: sz}).Len():// 确保可读的区间要 >= range
    return false
  case r.Len() == 0: // 抠掉的区间长度为空啥也不干
    // Noop
  case r.begin == 0: // 从read的开始的地方抠，假装抠掉的数据被读走了
    b.read += r.end
  case r.end == sz: // 从write地方往前抠，假装写的少了
    b.write -= r.Len()
  default:
    // Remove from the middle of b.data.
    // 从中间抠掉，读不改变，假装写的少了
    // |--------|
    // b.r |---|
    //     r.b r.e
    copy(b.data[b.read+r.begin:], b.data[b.read+r.end:b.write])
    b.write -= r.Len()
  }
  return true
}
   #+END_SRC
   好，buffer清楚之后就是bufferList了。 bufferList是个有头尾指针的双链表，用于串buffer，buffer里面的bufferEntry属性就是被它调用设置next/prev。作为数据结构的内容这里不描述了。
   接下来是pool
   #+BEGIN_SRC go
///home/coder/go/src/github.com/google/gvisor/pkg/buffer/pool.go:37
type pool struct {
  bufferSize      int
  avail           []buffer              `state:"nosave"`
  embeddedStorage [embeddedCount]buffer `state:"wait"`
}
   #+END_SRC
   avail最先指向embeddedStorage的某个index，后面用满了之后指向新make的slice。buffer在pool这个结构中仅关心位置，里面的buffer里面的data另外初始化。
   #+BEGIN_SRC go
///home/coder/go/src/github.com/google/gvisor/pkg/buffer/pool.go:51
// get gets a new buffer from p without initializing it.
func (p *pool) getNoInit() *buffer {
  //最一开始的情况， avail没有初始化，先绑定
  if p.avail == nil {
    p.avail = p.embeddedStorage[:]
  }
  // 这个case是avail已经被切片用完了，此时avail不为nil，但是len为0
  // 需要重新开辟空间
  if len(p.avail) == 0 {
    p.avail = make([]buffer, embeddedCount)
  }
  if p.bufferSize <= 0 {
    p.bufferSize = defaultBufferSize
  }
  buf := &p.avail[0]
  // 配合的是上面第二个判断
  p.avail = p.avail[1:]
  return buf
}

   #+END_SRC
   接下来就是View了。
   #+BEGIN_SRC go
// /home/coder/go/src/github.com/google/gvisor/pkg/buffer/view.go:31
type View struct {
  data bufferList
  size int64 // size表示的所有buffer加起来的长度，而不是分片buffer的个数
  pool pool
}
   #+END_SRC
   方法就不贴代码了，要贴得贴满了。

   构造函数： 静态创建即可，没有New...的pattern。

   以下函数介绍按出场顺序介绍：

   1. TrimFront(count int64) ==> 从前面砍掉多少个字节，核心实现在 advanceRead 里面。实现方法就是从双链表的头开始一个一个的切。 当前的这个buf还分两种case，够砍的和不够砍的，够砍的砍完结束(break)，不够砍的这个buf直接砍掉(从链表里Remove)，相应更新下一轮数据和全局的data长度size。 最后还判断一下进来的场景是不是砍掉的字节比总长度小，如果不满足就panic。这里也发现整个框架在不可能出现的case地方都是直接panic的。k8s里面的代码panic的数量远小于这里的。
   2. Remove(offset, length int) bool ==> 从某个位置开始抠掉一些数据显然就比上面直接从头砍要细节很多了。 offset,length基于全局的。
      + 首先确保区间的正确： 待抠的range要在整个数据区间之内
      + 抠的时候还要考虑区间跨buf的case。甚至是跨多个buf的情况。用的方法是一个curr区间，每次遍历bufferList的时候先更新curr.end为当前end,当然表示还是全局的表示，当和input比较时，有交集就清理这个交集，没有交集继续跳。curr.begin在当前buf比较结束时更新。区间更新的时机巧妙。删除的时候要把全局位移转变成当前buff的位移，所以有个设置Offset的行为。
   3. ReadAt(p []byte, offset int64) (int, error) ==> 从offset位置开始read，并且read满。
      + 要判断offset是否在当前区间上。用的方法是offset减去前面的偏移是否大于当前buf的长度，如果大于等于则说明开始位置不在当前这个区间上。忽略
        [[./include/images/buf-read-at.png]]
      + 注意一旦追上，只要开始copy，那么offset - skipped 就为0了，后面的buffer就是一直cp到p满为止或者EOF
   4. Truncate(length int64) ==> 强制缩到这个大小，不会长的，要求length必须 < size
      + 从后面开始往前遍历
      + 看看删除后的效果是否满足 < length，满足了, 这是最后一个了，干完收工，怎么干？ 假装写少了，更新write指针到满足条件处。不满足继续删，注意这里的判断条件不包括等于，等于的case删整个当前buffer留在下面做了。
        [[./include/images/buf-truncat.png]]
   5. Grow(length int64, zero bool) ==> 设置View的大小至length，zero表示是否用0填充
      + 判断最后一个是否为空或者还有空间可写？满足的话就从pool里拿个新的buffer。
      + 对这个可写的buf（最后一个或者是新拿的）进行写操作(更新buf.write指针)，稍微判断一下写空间是否绰绰有余，多的话就按照left要求来
   6. Prepend(data []byte) ==> 将data塞到前面去
      + 第一个还有空间吗？有就塞一点，动的是buf.read指针，读过的就不要了，放在这些位置上，还分情况：
        + 第一个空间足够如下图：
          [[./include/images/buf-has-space.png]]
        + 第一个空间不够，data写一点，buf写满
          [[./include/images/buf-not-enough.png]]
